{"version":3,"file":"static_js_components_CommentScrollArrow_vue.js","mappings":";;;;;;;;;;;;;;;;AAAiG;AAC3B;AACL;;;AAGjE;AACA,CAA6F;AAC7F,gBAAgB,uGAAU;AAC1B,EAAE,wFAAM;AACR,EAAE,0FAAM;AACR,EAAE,mGAAe;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,KAAU,EAAE,YAiBf;AACD;AACA,iEAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1B+B;;AAE9C,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0DAAQ;AAC/C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;;;;ACrNsI,CAAC,iEAAe,gJAAG,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEA5J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;;;;AClBA;;AAEA;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","sources":["webpack://Club/./static/js/components/CommentScrollArrow.vue","webpack://Club/static/js/components/CommentScrollArrow.vue","webpack://Club/./static/js/components/CommentScrollArrow.vue?9c83","webpack://Club/./static/js/components/CommentScrollArrow.vue?e5c6","webpack://Club/./static/js/components/CommentScrollArrow.vue?0855","webpack://Club/./node_modules/vue-loader/lib/runtime/componentNormalizer.js"],"sourcesContent":["import { render, staticRenderFns } from \"./CommentScrollArrow.vue?vue&type=template&id=d41cfa9a&\"\nimport script from \"./CommentScrollArrow.vue?vue&type=script&lang=js&\"\nexport * from \"./CommentScrollArrow.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (module.hot) {\n  var api = require(\"/app/frontend/node_modules/vue-hot-reload-api/dist/index.js\")\n  api.install(require('vue'))\n  if (api.compatible) {\n    module.hot.accept()\n    if (!api.isRecorded('d41cfa9a')) {\n      api.createRecord('d41cfa9a', component.options)\n    } else {\n      api.reload('d41cfa9a', component.options)\n    }\n    module.hot.accept(\"./CommentScrollArrow.vue?vue&type=template&id=d41cfa9a&\", function () {\n      api.rerender('d41cfa9a', {\n        render: render,\n        staticRenderFns: staticRenderFns\n      })\n    })\n  }\n}\ncomponent.options.__file = \"static/js/components/CommentScrollArrow.vue\"\nexport default component.exports","<template>\n    <span\n        class=\"comment-scroll-arrow\"\n        :class=\"{\n            'arrow-up': arrowDirection === 'Up'\n        }\"\n        @click.prevent=\"onArrowClickHandler\"\n    >\n    </span>\n</template>\n\n<script>\nimport { throttle } from \"../common/utils.js\";\n\nexport default {\n    name: \"CommentScrollArrow\",\n    data() {\n        return {\n            arrowDirection: \"Down\",\n            scrollThrottleDelay: 150,\n        };\n    },\n    methods: {\n        getBodyTop() {\n            return document.body.getBoundingClientRect().top;\n        },\n        getElementMargin(el) {\n             const style = window.getComputedStyle(el);\n             return parseInt(style.scrollMarginTop, 10);\n         },\n        scrollToElement(el, callback) {\n            const oldHash = document.location.hash;\n            const newHash = `#${el.id}`;\n            if (oldHash === newHash) {\n                // zero the hash so that there is no sticking if we are already on this element\n                history.pushState(null, null, '');\n            }\n\n            document.documentElement.style.scrollBehavior = \"smooth\";\n\n            const offset = el.getBoundingClientRect().top - this.getBodyTop() - this.getElementMargin(el);\n\n            const onScroll = () => {\n                const scrolledToElement = Math.abs(offset - window.pageYOffset) < 1;\n                const scrolledToBottom = Math.abs(document.body.getBoundingClientRect().height - window.pageYOffset - window.innerHeight) < 1;\n                if (scrolledToElement || (this.arrowDirection === \"Down\" && scrolledToBottom)) {\n                    window.removeEventListener('scroll', onScroll);\n\n                    document.documentElement.style.scrollBehavior = \"auto\";\n\n                    if (callback) {\n                        callback();\n                    }\n                }\n            };\n\n            window.addEventListener(\"scroll\", onScroll);\n            onScroll();\n\n            document.location.replace(`#${el.id}`);\n        },\n        scrollExtreme(direction) {\n            if (direction === \"Down\") {\n                const postCommentsForm = document.getElementById(\"post-comments-form\");\n                const footer = document.getElementById(\"footer\");\n\n                const downTarget = postCommentsForm || footer;\n                this.scrollToElement(downTarget);\n\n                this.arrowDirection = \"Up\";\n            } else {\n                const topTarget = document.getElementById(\"app\");\n                this.scrollToElement(topTarget);\n\n                this.arrowDirection = \"Down\";\n            }\n        },\n        scrollToComment(direction) {\n            let comments = document.querySelectorAll(\n                 [\n                     // Просто новые комментарии\n                     \".comment.comment-is-new\",\n                     // Новые реплаи к старым комментариям\n                     \".comment:not(.comment-is-new) > .comment-replies > .replies > .reply.comment-is-new\",\n                     // Новые реплаи на втором уровне к старым реплаям старых комментариев\n                     \".comment:not(.comment-is-new) > .comment-replies > .replies > .reply:not(.comment-is-new) > .reply-replies > .replies > .reply.comment-is-new\",\n                     // Новые реплаи без родительского комментария\n                     \".post-comments-list > .replies > .reply.comment-is-new\",\n                     // Новые реплаи на втором уровне к старым реплаям без родительского комментария\n                     \".post-comments-list > .replies > .reply:not(.comment-is-new) > .reply.comment-is-new\",\n                     // Новые реплаи на втором уровне бэтлов\n                     \".battle-comments .post-comments-list > .replies > .reply:not(.comment-is-new) > .reply-replies >.replies > .reply.comment-is-new\",\n                 ].join()\n             );\n\n            const bodyTop = this.getBodyTop();\n\n            if (comments.length < 1) {\n                // Новых нет, ищем начало блока комментариев и перебираем прочтённые комментарии\n                comments = document.querySelectorAll(\"#post-comments-title, .comment\");\n            }\n\n            if (comments.length < 1) {\n                // Then post without comments\n                return this.scrollExtreme(direction);\n            }\n\n            const position = window.scrollY + this.getElementMargin(comments[0]);\n\n            // Убираем комментарии ниже или выше направления поиска\n            const filteredComments = [...comments].filter((el) => {\n                const elTop = el.getBoundingClientRect().top;\n                const elTopMargin = this.getElementMargin(el);\n\n                return (direction === \"Down\") ? elTop - elTopMargin > 2 : elTop < 0;\n            });\n\n            if (filteredComments.length < 1) {\n                return this.scrollExtreme(direction);\n            }\n\n            // Находим ближайший комментарий\n            const nearest = [...filteredComments].reduce((a, b) => {\n                const atop = a.getBoundingClientRect().top - bodyTop;\n                const btop = b.getBoundingClientRect().top - bodyTop;\n                return Math.abs(btop - position) < Math.abs(atop - position) ? b : a;\n            });\n\n            /**\n             * remove selected class from previous selected comment\n             * do not delete immediately comment-scroll-selected class for override the target comment style\n             */\n            const alreadySelected = document.querySelector(\".comment-scroll-selected\");\n            if (alreadySelected) {\n                alreadySelected.classList.remove(\"comment-scroll-selected\");\n            }\n            nearest.classList.add(\"comment-scroll-selected\");\n\n            const highlightComment = () => {\n                nearest.classList.add(\"comment-scroll-animation\");\n\n                window.setTimeout(() => {\n                     nearest.classList.remove(\"comment-scroll-animation\");\n                }, 500);\n            };\n\n            this.scrollToElement(nearest, highlightComment);\n        },\n        onArrowClickHandler() {\n            if (event.shiftKey) {\n                const direction = this.arrowDirection == \"Up\" ? \"Down\" : \"Up\";\n                this.scrollToComment(direction);\n            } else if (this.arrowDirection == \"Up\") {\n                this.scrollExtreme(this.arrowDirection);\n            } else {\n                this.scrollToComment(this.arrowDirection);\n            }\n        },\n        initOnPageScroll() {\n            this.onPageScrollHandler = throttle(() => {\n                const bottomOfWindow = Math.abs(document.body.getBoundingClientRect().height - window.pageYOffset - window.innerHeight) < 1;\n                const topOfWindow = window.pageYOffset === 0;\n\n                if (bottomOfWindow) {\n                    this.arrowDirection = \"Up\";\n                }\n\n                if (topOfWindow) {\n                    this.arrowDirection = \"Down\";\n                }\n            }, this.scrollThrottleDelay);\n\n            window.addEventListener(\"scroll\", this.onPageScrollHandler);\n        },\n        initOnKeyUp() {\n             this.keyUpHandler = (e) => {\n                // ctrl-up/down для всех, а в macos и FF - ⇧⌃↑/↓\n                const isFirefox = (\"netscape\" in window) && / rv:/.test(navigator.userAgent);\n                if (!e.ctrlKey || (isFirefox && !e.shiftKey)\n                    || [\"ArrowDown\", \"ArrowUp\", \"Down\", \"Up\"].indexOf(e.key) < 0) {\n                    return;\n                }\n\n                e.preventDefault();\n                this.arrowDirection = e.key.replace(/^Arrow/, \"\");\n                this.scrollToComment(this.arrowDirection);\n            };\n\n            document.addEventListener(\"keyup\", this.keyUpHandler);\n        },\n        initSelectedClassCleanerListener() {\n            document.querySelector('#comments').addEventListener(\"click\", (event) => {\n                if (event.target.classList.contains(\"comment-header-date\")) {\n                    const selectedComment = event.target.closest(\".comment-scroll-selected\");\n                    if (selectedComment) {\n                        selectedComment.classList.remove(\"comment-scroll-selected\");\n                    }\n                }\n            }, false);\n        },\n        init() {\n            this.initOnKeyUp();\n            this.initOnPageScroll();\n            this.initSelectedClassCleanerListener();\n        }\n    },\n    mounted() {\n        this.init();\n    },\n    beforeDestroy() {\n        document.removeEventListener(\"keyup\", this.keyUpHandler);\n        window.removeEventListener(\"scroll\", this.onPageScrollHandler);\n    },\n};\n</script>\n","import mod from \"-!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CommentScrollArrow.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CommentScrollArrow.vue?vue&type=script&lang=js&\"","export * from \"-!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CommentScrollArrow.vue?vue&type=template&id=d41cfa9a&\"","var render = function () {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"span\", {\n    staticClass: \"comment-scroll-arrow\",\n    class: {\n      \"arrow-up\": _vm.arrowDirection === \"Up\",\n    },\n    on: {\n      click: function ($event) {\n        $event.preventDefault()\n        return _vm.onArrowClickHandler($event)\n      },\n    },\n  })\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\nexport { render, staticRenderFns }","/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nexport default function normalizeComponent(\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */,\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options =\n    typeof scriptExports === 'function' ? scriptExports.options : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) {\n    // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () {\n          injectStyles.call(\n            this,\n            (options.functional ? this.parent : this).$root.$options.shadowRoot\n          )\n        }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functional component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection(h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing ? [].concat(existing, hook) : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n"],"names":[],"sourceRoot":""}