{"version":3,"file":"static_js_components_CommentMarkdownEditor_vue.js","mappings":";;;;;;;;;;;;;;;;AAAoG;AAC3B;AACL;;;AAGpE;AACA,CAA6F;AAC7F,gBAAgB,uGAAU;AAC1B,EAAE,2FAAM;AACR,EAAE,6FAAM;AACR,EAAE,sGAAe;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,KAAU,EAAE,YAiBf;AACD;AACA,iEAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACdsC;AAC+D;;AAEpH,iEAAe;AACf;AACA,YAAY,uDAAQ;AACpB;AACA;;AAEA;AACA,sBAAsB,6EAAoB;AAC1C;AACA;;AAEA,6DAA6D,kFAA6B;AAC1F,4EAA4E,uEAAkB;;AAE9F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uDAAQ;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;;;;AChOyI,CAAC,iEAAe,mJAAG,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEA/J;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,wCAAwC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA;AACA,kBAAkB,4DAA4D;AAC9E;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3DA;;AAEA;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","sources":["webpack://Club/./static/js/components/CommentMarkdownEditor.vue","webpack://Club/static/js/components/CommentMarkdownEditor.vue","webpack://Club/./static/js/components/CommentMarkdownEditor.vue?2798","webpack://Club/./static/js/components/CommentMarkdownEditor.vue?2bcd","webpack://Club/./static/js/components/CommentMarkdownEditor.vue?44fe","webpack://Club/./node_modules/vue-loader/lib/runtime/componentNormalizer.js"],"sourcesContent":["import { render, staticRenderFns } from \"./CommentMarkdownEditor.vue?vue&type=template&id=367912d6&\"\nimport script from \"./CommentMarkdownEditor.vue?vue&type=script&lang=js&\"\nexport * from \"./CommentMarkdownEditor.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (module.hot) {\n  var api = require(\"/app/frontend/node_modules/vue-hot-reload-api/dist/index.js\")\n  api.install(require('vue'))\n  if (api.compatible) {\n    module.hot.accept()\n    if (!api.isRecorded('367912d6')) {\n      api.createRecord('367912d6', component.options)\n    } else {\n      api.reload('367912d6', component.options)\n    }\n    module.hot.accept(\"./CommentMarkdownEditor.vue?vue&type=template&id=367912d6&\", function () {\n      api.rerender('367912d6', {\n        render: render,\n        staticRenderFns: staticRenderFns\n      })\n    })\n  }\n}\ncomponent.options.__file = \"static/js/components/CommentMarkdownEditor.vue\"\nexport default component.exports","<template>\n    <div class=\"comment-markdown-editor\">\n        <slot></slot>\n        <div\n            class=\"mention-autocomplete-hint\"\n            v-show=\"users.length > 0\"\n            :style=\"{\n                top: autocomplete ? autocomplete.top + 'px' : 0,\n                left: autocomplete ? autocomplete.left + 'px' : 0,\n            }\"\n        >\n            <div\n                v-for=\"(user, index) in users.slice(0, 5)\"\n                :class=\"{ 'mention-autocomplete-hint__option--suggested': index === selectedUserIndex }\"\n                @click=\"insertSuggestion(user)\"\n                class=\"mention-autocomplete-hint__option\"\n            >\n                {{ user.slug }}<span class=\"mention-autocomplete-hint__option-full_name\">{{ user.full_name }}</span>\n            </div>\n        </div>\n    </div>\n</template>\n\n<script>\nimport { isMobile, throttle } from \"../common/utils\";\nimport { createMarkdownEditor, handleFormSubmissionShortcuts, imageUploadOptions } from \"../common/markdown-editor\";\n\nexport default {\n    mounted() {\n        if (isMobile()) {\n            return;\n        }\n\n        const $markdownElementDiv = this.$el.children[0];\n        this.editor = createMarkdownEditor($markdownElementDiv, {\n            toolbar: false,\n        });\n\n        this.editor.element.form.addEventListener(\"keydown\", handleFormSubmissionShortcuts);\n        inlineAttachment.editors.codemirror4.attach(this.editor.codemirror, imageUploadOptions);\n\n        this.editor.codemirror.on(\"change\", this.handleAutocompleteHintTrigger);\n        this.editor.codemirror.on(\"change\", this.handleSuggest);\n\n        this.populateCacheWithCommentAuthors();\n    },\n    watch: {\n        users: function (val, oldVal) {\n            if (val.length > 0) {\n                this.selectedUserIndex = 0;\n                document.addEventListener(\"keydown\", this.handleKeydown, true);\n            } else {\n                document.removeEventListener(\"keydown\", this.handleKeydown, true);\n            }\n        },\n    },\n    data() {\n        return {\n            selectedUserIndex: null,\n            postSlug: null,\n            users: [],\n            autocomplete: null,\n            autocompleteCache: {\n                samples: {},\n                users: {},\n            },\n        };\n    },\n    methods: {\n        handleKeydown(event) {\n            if (\n                event.code !== \"ArrowDown\" &&\n                event.code !== \"ArrowUp\" &&\n                event.code !== \"Tab\" &&\n                event.code !== \"Enter\"\n            ) {\n                return;\n            }\n\n            event.preventDefault();\n\n            if (event.code === \"Enter\" || event.code === \"Tab\") {\n                this.insertSuggestion(this.users[this.selectedUserIndex]);\n            } else if (event.code === \"ArrowDown\" && this.selectedUserIndex + 1 < this.users.length) {\n                this.selectedUserIndex += 1;\n            } else if (event.code === \"ArrowUp\" && this.selectedUserIndex - 1 >= 0) {\n                this.selectedUserIndex -= 1;\n            }\n        },\n        triggersAutocomplete(cm, event) {\n            const eventText = event.text.join(\"\");\n            if (eventText !== \"@\") {\n                return false;\n            }\n\n            const prevSymbol = cm.getRange(\n                {\n                    line: event.from.line,\n                    ch: event.from.ch - 1,\n                },\n                event.from\n            );\n\n            return prevSymbol.trim() === \"\";\n        },\n        insertSuggestion(user) {\n            if (!this.autocomplete) {\n                return;\n            }\n\n            const { line, ch } = this.autocomplete;\n            const cursor = this.editor.codemirror.getCursor();\n\n            this.resetAutocomplete();\n\n            this.editor.codemirror.replaceRange(\n                `${user.slug} `,\n                {\n                    line,\n                    ch: ch + 1,\n                },\n                {\n                    line: cursor.line,\n                    ch: cursor.ch,\n                }\n            );\n        },\n        populateCacheWithCommentAuthors: function () {\n            document.querySelectorAll(\".comment-header-author-name\").forEach((linkEl) => {\n                const slug = linkEl.dataset.authorSlug;\n                const full_name = linkEl.innerText;\n\n                if (!slug || !full_name) {\n                    return;\n                }\n\n                this.autocompleteCache.users[slug] = {\n                    slug,\n                    full_name,\n                };\n            });\n        },\n        fetchAutocompleteSuggestions: throttle(function (sample) {\n            fetch(`/search/users.json?prefix=${sample}`)\n                .then((res) => {\n                    if (!res.url.includes(`prefix=${sample}`)) {\n                        return { users: [] };\n                    }\n\n                    return res.json();\n                })\n                .then((data) => {\n                    if (!this.autocomplete) {\n                        return;\n                    }\n\n                    this.users = data.users;\n\n                    this.autocompleteCache.samples[sample] = this.users;\n\n                    this.users.forEach((user) => {\n                        this.autocompleteCache.users[user.slug] = user;\n                    });\n                });\n        }, 600),\n        handleAutocompleteHintTrigger(cm, event) {\n            if (this.autocomplete) {\n                const eventText = event.text.join(\"\");\n                const eventRemoved = event.removed.join(\"\");\n                if ([\" \", \"@\"].includes(eventText) || eventRemoved.includes(\"@\")) {\n                    this.resetAutocomplete();\n                }\n\n                return;\n            }\n\n            if (event.origin === \"+input\" && this.triggersAutocomplete(cm, event)) {\n                const cursorCoords = this.editor.codemirror.cursorCoords(false, \"local\");\n\n                this.autocomplete = {\n                    ...event.from,\n                    top: cursorCoords.top + 36, // first line offset\n                    left: Math.floor(cursorCoords.left),\n                };\n            }\n        },\n        handleSuggest(cm, event) {\n            if (!this.autocomplete) {\n                return;\n            }\n\n            const value = this.editor.value();\n\n            const line = value.split(\"\\n\")[this.autocomplete.line];\n\n            const cursor = this.editor.codemirror.getCursor();\n            const sample = line.substring(this.autocomplete.ch, cursor.ch).substring(1);\n\n            // For short samples lookup users directly\n            if (sample.length < 3) {\n                const cacheKeys = Object.keys(this.autocompleteCache.users).filter((k) => k.includes(sample));\n                if (cacheKeys) {\n                    this.users = cacheKeys.map((k) => this.autocompleteCache.users[k]);\n                }\n\n                return;\n            }\n\n            // For longer samples lookup a whole cached sample\n            const cachedSample = this.autocompleteCache.samples[sample];\n            if (cachedSample) {\n                this.users = cachedSample;\n\n                return;\n            }\n\n            this.fetchAutocompleteSuggestions(sample);\n        },\n        resetAutocomplete() {\n            this.autocomplete = null;\n            this.users = [];\n            this.editor.codemirror.focus();\n        },\n    },\n};\n</script>\n","import mod from \"-!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CommentMarkdownEditor.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CommentMarkdownEditor.vue?vue&type=script&lang=js&\"","export * from \"-!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CommentMarkdownEditor.vue?vue&type=template&id=367912d6&\"","var render = function () {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    \"div\",\n    { staticClass: \"comment-markdown-editor\" },\n    [\n      _vm._t(\"default\"),\n      _vm._v(\" \"),\n      _c(\n        \"div\",\n        {\n          directives: [\n            {\n              name: \"show\",\n              rawName: \"v-show\",\n              value: _vm.users.length > 0,\n              expression: \"users.length > 0\",\n            },\n          ],\n          staticClass: \"mention-autocomplete-hint\",\n          style: {\n            top: _vm.autocomplete ? _vm.autocomplete.top + \"px\" : 0,\n            left: _vm.autocomplete ? _vm.autocomplete.left + \"px\" : 0,\n          },\n        },\n        _vm._l(_vm.users.slice(0, 5), function (user, index) {\n          return _c(\n            \"div\",\n            {\n              staticClass: \"mention-autocomplete-hint__option\",\n              class: {\n                \"mention-autocomplete-hint__option--suggested\":\n                  index === _vm.selectedUserIndex,\n              },\n              on: {\n                click: function ($event) {\n                  return _vm.insertSuggestion(user)\n                },\n              },\n            },\n            [\n              _vm._v(\"\\n            \" + _vm._s(user.slug)),\n              _c(\n                \"span\",\n                { staticClass: \"mention-autocomplete-hint__option-full_name\" },\n                [_vm._v(_vm._s(user.full_name))]\n              ),\n            ]\n          )\n        }),\n        0\n      ),\n    ],\n    2\n  )\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\nexport { render, staticRenderFns }","/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nexport default function normalizeComponent(\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */,\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options =\n    typeof scriptExports === 'function' ? scriptExports.options : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) {\n    // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () {\n          injectStyles.call(\n            this,\n            (options.functional ? this.parent : this).$root.$options.shadowRoot\n          )\n        }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functional component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection(h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing ? [].concat(existing, hook) : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n"],"names":[],"sourceRoot":""}